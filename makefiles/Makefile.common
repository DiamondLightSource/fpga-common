MUST_DEFINE += FPGA_COMMON      # Path to this project
MUST_DEFINE += PROJECT_TOP
MUST_DEFINE += BUILD_TOP
MUST_DEFINE += VIVADO
MUST_DEFINE += VSIM
MUST_DEFINE += MODELSIM_LIBS


# ------------------------------------------------------------------------------

# The following extremly tricksy makefile code converts the list of MUST_DEFINE
# names into symbols which will generate a suitable error when an attempt is
# made to expand them.  These will be defined in the CONFIG file.
define _MUST_DEFINE
ifndef $1
    $1 = $$(error Must define symbol $1 in CONFIG or Make file)
endif
endef
_EVAL_MUST_DEFINE = $(eval $(_MUST_DEFINE))
$(foreach var,$(MUST_DEFINE),$(call _EVAL_MUST_DEFINE,$(var)))


# # A nice bit of code from https://www.systutorials.com/
# #   how-to-get-the-full-path-and-directory-of-a-makefile-itself/
# mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))
# mkfile_dir := $(dir $(mkfile_path))


# Function for safely quoting a string before exposing it to the shell.
# Wraps string in quotes, and escapes all internal quotes.  Invoke as
#
#   $(call SAFE_QUOTE,string to expand)
#
SAFE_QUOTE = '$(subst ','\'',$(1))'
# )' (Gets vim back in sync)


# Passing makefile exports through is a bit tiresome.  We could mark our
# symbols with export -- but that means *every* command gets them, and I
# don't like that.  This macro instead just exports the listed symbols into a
# called function, designed to be called like:
#
#       $(call EXPORT,$(EXPORTS)) script
#
EXPORT = $(foreach var,$(1),$(var)=$(call SAFE_QUOTE,$($(var))))

# Similarly, this is used to pass TCL arguments through after safe quoting
#
#       $(call TCL_ARGS,$(ARGS))
#
TCL_ARGS = $(foreach var,$(1),-tclargs $(call SAFE_QUOTE,$($(var))))


# Sometimes we allow a parameter to be specified either as a name which we
# look up in a predefined directory, or as a fixed path.  This macro
# encapsulates this, designed to be called thus:
#
#   $(call COMPUTE_PATH,param_name,path_name,default_dir)
#
# Here param_name is the name of the parameter that may be updated, path_name
# will be updated with the full path to the identifed component, and
# default_dir is the default base directory.
#
# This supports three ways of defining param_name:
#
#   1. param_name=name
#       In this case path_name is set to default_dir/name.  This is the
#       normal case when a default configuration can be used.
#   2. param_name=/path/to/name
#       In this case path_name is set to /path/to/name and param_name is
#       forced to name.  This is the case when an external configuration is
#       used.
define _COMPUTE_PATH
    ifndef $1
        $$(error Must specify value for $1)
    endif
    ifdef $2
        $$(warning Parameter $2 will be redefined)
    endif
    ifeq (,$$(findstring /,$$($1)))
        # $1 is not a path, can just set path to default location
        $2 := $3/$$($1)
    else
        # $1 defines a path.  Split into two to set $1 and $2 together.
        $2 := $$($1)
        override $1 := $$(notdir $$($1))
        ifndef $1
            $$(error $1 cannot end in /)
        endif
    endif
endef
COMPUTE_PATH = $(eval $(_COMPUTE_PATH))


# ------------------------------------------------------------------------------


PYTHON ?= python

BOARD ?= none

# By default pick up the project name from the directory name of the project
# top.  This can be overridden in the CONFIG file.
PROJECT_NAME ?= $(notdir $(PROJECT_TOP))


# Convert license file from space separated to : separated list
SPACE := $(subst ,, )
export LM_LICENSE_FILE := $(subst $(SPACE),:,$(strip $(LM_LICENSE_FILE)))

COMMON_VHD = $(FPGA_COMMON)/vhd
COMMON_SIM = $(FPGA_COMMON)/sim/common
TOOLS_DIR = $(FPGA_COMMON)/tools

# Compute board directory from BOARD definition.  By default we look inside our
# boards directory for board definitions, but BOARD can be an absolute path
# instead if required.
$(call COMPUTE_PATH,BOARD,BOARD_DIR,$(FPGA_COMMON)/boards)

# Path to constraints directory for project
CONSTR_DIR = $(PROJECT_TOP)/constr


# vim: set filetype=make:
