-- Control over capture of a single burst formatted data stream

-- Generates sequential addresses and ensures an entire burst is buffered before
-- generating an address.  Also takes care to ensure that all bursts are the
-- correct length, so will properly handle the malformed bursts that can be
-- generated by filter synchronisation.

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.support.all;
use work.axi_defs.all;
use work.stream_defs.all;

entity stream_bursts is
    generic (
        LOG_BURST_LENGTH : natural;         -- log2 of burst length
        ADDRESS_WIDTH : natural := 31;
        LOG_DATA_BYTES : natural := 2;      -- 4 bytes, 32 bits
        ADDRESS_FIFO_DEPTH : natural := 2;
        LOG_DATA_FIFO_DEPTH : natural := 1;
        ENABLE_FLOW_CONTROL : boolean := false
    );
    port (
        clk_i : in std_ulogic;

        -- Data stream
        -- Note that due to a restriction in stream_bursts_stream there *must*
        -- be at least one tick of delay between bursts in this stream.
        stream_i : in data_stream_t;
        -- If ENABLE_FLOW_CONTROL is false this can be ignored, otherwise normal
        -- data flow handshaking must be used.
        stream_ready_o : out std_ulogic;

        -- Write interface to AXI slave
        axi_o : out axi_write_t(
            address(ADDRESS_WIDTH-1 downto LOG_DATA_BYTES),
            data(8 * 2**LOG_DATA_BYTES-1 downto 0));
        axi_i : in axi_write_ready_t;

        -- Enable capture.  Hold this high until capture_ready_o is set.
        capture_enable_i : in std_ulogic;
        capture_ready_o : out std_ulogic;
        -- Counts bursts as they are sent, marks updates to capture_address_o
        count_sent_o : out std_ulogic;

        -- Range of capture addresses.  This is specified in multiples of burst
        -- length as capture is recorded in bursts
        first_address_i : in unsigned;
        last_address_i : in unsigned;
        -- This is the address of the currently written burst
        capture_address_o : out unsigned;

        -- Set when data cannot be sent
        data_error_o : out std_ulogic;
        -- Set when burst reshaping required
        framing_error_o : out std_ulogic
    );
end;

architecture arch of stream_bursts is
    -- Address control
    subtype ADDRESS_RANGE is natural
        range ADDRESS_WIDTH - 1 downto LOG_BURST_LENGTH + LOG_DATA_BYTES;
    signal address_out : unsigned(ADDRESS_RANGE);
    signal address_ready : std_ulogic;
    signal reset_address : std_ulogic;
    signal write_address : std_ulogic;

    -- Data control
    signal write_data_ready : std_ulogic;
    signal write_data_valid : std_ulogic;
    signal write_data_last : std_ulogic;
    signal write_data_enable : std_ulogic;

begin
    -- Interface to AXI.  Includes both data and address FIFO.  Data is gathered
    -- into the data FIFO until a complete burst is ready, and then the address
    -- is written.  Flow control requires that we don't send data unless the
    -- address FIFO is ready.
    fifo : entity work.stream_bursts_fifo generic map (
        LOG_BURST_LENGTH => LOG_BURST_LENGTH,
        ADDRESS_FIFO_DEPTH => ADDRESS_FIFO_DEPTH,
        LOG_DATA_FIFO_DEPTH => LOG_DATA_FIFO_DEPTH
    ) port map (
        clk_i => clk_i,

        address_ready_o => address_ready,
        address_valid_i => write_address,
        address_i => address_out,

        data_ready_o => write_data_ready,
        data_valid_i => write_data_valid,
        data_last_i => write_data_last,
        data_i => stream_i.data,
        data_enable_i => write_data_enable,

        axi_o => axi_o,
        axi_i => axi_i
    );


    -- Address management under control of stream_bursts_state
    address : entity work.stream_bursts_address port map (
        clk_i => clk_i,

        reset_address_i => reset_address,
        advance_address_i => write_address,

        address_o => address_out,

        first_address_i => first_address_i,
        last_address_i => last_address_i,

        count_sent_o => count_sent_o,
        capture_address_o => capture_address_o
    );


    state : entity work.stream_bursts_state generic map (
        LOG_BURST_LENGTH => LOG_BURST_LENGTH,
        ENABLE_FLOW_CONTROL => ENABLE_FLOW_CONTROL
    ) port map (
        clk_i => clk_i,

        data_valid_i => stream_i.valid,
        data_last_i => stream_i.last,
        data_ready_o => stream_ready_o,

        reset_address_o => reset_address,
        write_address_o => write_address,
        address_ready_i => address_ready,

        write_data_ready_i => write_data_ready,
        write_data_valid_o => write_data_valid,
        write_data_last_o => write_data_last,
        write_data_enable_o => write_data_enable,

        capture_enable_i => capture_enable_i,
        capture_ready_o => capture_ready_o,

        data_error_o => data_error_o,
        framing_error_o => framing_error_o
    );
end;
