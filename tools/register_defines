#!/usr/bin/env python

from __future__ import print_function

import argparse
from collections import OrderedDict

# Ensure we can find the path to fpga_lib
import fixup_imports
from fpga_lib import parse


head_template = '''\
--
-- DO NOT EDIT THIS FILE !!!
--
-- This file has been automatically generated.
-- To change this file edit the source file and rebuild.
--

-- Register definitions

package %s is
'''
tail_template = 'end;'

reg_template   = '    constant %(reg_name)s : natural := %(index)d;'

subtype_template = '    subtype %%(reg_name)s is natural range %s;'
range_templates = {
    'to'     : subtype_template % '%(low)d to %(high)d',
    'downto' : subtype_template % '%(high)d downto %(low)d',
}


def prefix_name(prefix, name, suffix):
    result = '%s%s' % ('_'.join(prefix + ['']), name)
    if suffix:
        result = '%s_%s' % (result, suffix)
    return result

# Emits a range of register values
def emit_range(prefix, name, range, suffix, direction):
    low, count = range
    high = low + count - 1
    reg_name = prefix_name(prefix, name, suffix)
    template = range_templates[direction]
    print(template % locals())

def emit_constant(prefix, name, index, suffix):
    reg_name = prefix_name(prefix, name, suffix)
    print(reg_template % locals())


class Generate(parse.register_defines.WalkParse):
    def walk_register_array(self, prefix, array):
        emit_range(prefix, array.name, array.range, 'REGS', 'to')
        self.walk_fields(prefix + [array.name], array)

    def walk_field(self, prefix, field):
        if field.is_bit:
            emit_constant(prefix, field.name, field.range[0], 'BIT')
        else:
            emit_range(prefix, field.name, field.range, 'BITS', 'downto')

    def walk_register(self, prefix, register, suffix = 'REG'):
        emit_constant(prefix, register.name, register.offset, suffix)
        self.walk_fields(prefix + [register.name], register)

    def walk_group(self, prefix, group):
        suffix = 'REGS' if prefix else 'REGS_RANGE'
        emit_range(prefix, group.name, group.range, suffix, 'to')
        if not group.hidden:
            prefix = prefix + [group.name]
        self.walk_subgroups(prefix, group)

    def walk_rw_pair(self, prefix, rw_pair):
        for reg in rw_pair.registers:
            self.walk_register(prefix, reg, suffix = 'REG_' + reg.rw[:1])

    def walk_overlay(self, prefix, overlay):
        emit_constant(prefix, overlay.name, overlay.offset, 'REG')
        for reg in overlay.registers:
            self.walk_register(prefix + [overlay.name], reg, suffix = 'OVL')

    def walk_union(self, prefix, union):
        if union.name:
            emit_constant(prefix, union.name, union.range[0], 'REG')
        self.walk_subgroups(prefix, union)

    def walk_constant(self, prefix, constant):
        emit_constant(prefix, constant.name, constant.value, '')


def generate_list(walk, values):
    for value in values:
        print('    -- Definitions for %s' % value.name)
        walk([], value)
        print()

def generate_constants(walk, constants):
    print('    -- Constants')
    for constant in constants.values():
        walk([], constant)
    print()

# Generates complete package definition
def generate_package(package, parse):
    generate = Generate()
    print(head_template % package)
    generate_constants(generate.walk_constant, parse.constants)
    generate_list(generate.walk_register, parse.register_defines)
    generate_list(generate.walk_group, parse.group_defs)
    generate_list(generate.walk_group, parse.groups)
    print(tail_template)


def parse_input(filename, defines = None):
    parsed_indent = parse.indent.parse_file(open(filename))
    return parse.register_defines.parse_defs(parsed_indent, defines)


def parse_args():
    parser = argparse.ArgumentParser(
        description = '''\
Generate VHDL register definitions from register description file.''')
    parser.add_argument('input', help = 'Register description file')
    parser.add_argument('--name', '-n', default = 'register_defines',
        help = 'Name of package to generate')
    parser.add_argument('--include', '-i', action = 'append', default = [],
        help = 'Packages to include in parsed result')
    return parser.parse_args()


def process_includes(includes):
    defines = OrderedDict()

    for filename in includes:
        parsed = parse_input(filename)
        for group in parsed.groups:
            assert group.name not in defines, \
                'Multiple definitions of group "%s"' % group.name
            defines[group.name] = group._replace(content = [])
    return defines


if __name__ == '__main__':
    args = parse_args()

    defines = process_includes(args.include)
    parsed = parse_input(args.input, defines)
    generate_package(args.name, parsed)
